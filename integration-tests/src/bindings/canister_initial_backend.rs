// This is an experimental feature used to generate Rust bindings from Candid.
// THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE TO AVOID DATA LOSS.
#![allow(dead_code, unused_imports, non_snake_case)]
use candid::{self, CandidType, Decode, Deserialize, Encode, Principal};

pub struct CanisterInitialBackendCanister {
    pub canister_id: Principal,
    pub caller: super::Caller,
}

impl CanisterInitialBackendCanister {
    pub fn append_chunk(&self, arg0: String, arg1: u64) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "append_chunk",
            args,
        )
    }
    pub fn append_text(&self, arg0: String, arg1: String, arg2: u64) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0, &arg1, &arg2);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "append_text",
            args,
        )
    }
    pub fn check_dir_is_writable(&self, arg0: String) -> super::CallBuilder<String> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "check_dir_is_writable",
            args,
        )
    }
    pub fn check_new_dir_is_writable(&self, arg0: String) -> super::CallBuilder<String> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "check_new_dir_is_writable",
            args,
        )
    }
    pub fn check_new_file_is_writable(&self, arg0: String) -> super::CallBuilder<String> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "check_new_file_is_writable",
            args,
        )
    }
    pub fn chunk_size(&self) -> super::CallBuilder<u64> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "chunk_size",
            args,
        )
    }
    pub fn clear_chunk(&self) -> super::CallBuilder<()> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "clear_chunk",
            args,
        )
    }
    pub fn create_depth_folders(&self, arg0: String, arg1: u64) -> super::CallBuilder<String> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "create_depth_folders",
            args,
        )
    }
    pub fn create_files(&self, arg0: String, arg1: u64) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "create_files",
            args,
        )
    }
    pub fn current_dir(&self) -> super::CallBuilder<String> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "current_dir",
            args,
        )
    }
    pub fn delete_depth_folders(&self, arg0: String, arg1: u64) -> super::CallBuilder<String> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "delete_depth_folders",
            args,
        )
    }
    pub fn delete_file(&self, arg0: String) -> super::CallBuilder<()> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "delete_file",
            args,
        )
    }
    pub fn delete_folder(&self, arg0: String) -> super::CallBuilder<()> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "delete_folder",
            args,
        )
    }
    pub fn file_size(&self, arg0: String) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "file_size", args)
    }
    pub fn greet(&self, arg0: String) -> super::CallBuilder<String> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "greet", args)
    }
    pub fn list_all_files(&self, arg0: String) -> super::CallBuilder<Vec<String>> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "list_all_files",
            args,
        )
    }
    pub fn list_files(&self, arg0: String) -> super::CallBuilder<Vec<String>> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "list_files", args)
    }
    pub fn load_chunk(&self, arg0: String) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "load_chunk",
            args,
        )
    }
    pub fn load_chunk_map(&self, arg0: u64) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "load_chunk_map",
            args,
        )
    }
    pub fn read_chunk(&self, arg0: u64, arg1: u64) -> super::CallBuilder<String> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "read_chunk",
            args,
        )
    }
    pub fn read_kb(
        &self,
        arg0: String,
        arg1: u64,
        arg2: u64,
    ) -> super::CallBuilder<serde_bytes::ByteBuf> {
        let args = Encode!(&arg0, &arg1, &arg2);
        self.caller
            .call(self.canister_id, super::CallMode::Update, "read_kb", args)
    }
    pub fn read_text(&self, arg0: String, arg1: i64, arg2: u64) -> super::CallBuilder<String> {
        let args = Encode!(&arg0, &arg1, &arg2);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "read_text", args)
    }
    pub fn set_current_dir(&self, arg0: String) -> super::CallBuilder<()> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "set_current_dir",
            args,
        )
    }
    pub fn store_chunk(&self, arg0: String) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "store_chunk",
            args,
        )
    }
    pub fn store_chunk_map(&self, arg0: u64) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "store_chunk_map",
            args,
        )
    }
    pub fn store_chunk_map_4_k(&self, arg0: u64) -> super::CallBuilder<(u64, u64)> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "store_chunk_map4k",
            args,
        )
    }
    pub fn write_kb_text(&self, arg0: String, arg1: u64) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "write_kb_text",
            args,
        )
    }
    pub fn write_kb_text_buf(&self, arg0: String, arg1: u64) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "write_kb_text_buf",
            args,
        )
    }
    pub fn write_mib_text(&self, arg0: String, arg1: u64) -> super::CallBuilder<u64> {
        let args = Encode!(&arg0, &arg1);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "write_mib_text",
            args,
        )
    }
    pub fn zero_chunk(&self) -> super::CallBuilder<()> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "zero_chunk",
            args,
        )
    }
}

pub fn new(caller: &super::Caller, canister_id: Principal) -> CanisterInitialBackendCanister {
    CanisterInitialBackendCanister {
        canister_id,
        caller: caller.clone(),
    }
}

pub fn deploy(deployer: &super::Deployer) -> super::DeployBuilder<CanisterInitialBackendCanister> {
    let args = Encode!();
    let result = deployer.deploy(args, new);
    let result = if let Some(id) = canister_id() {
        result.with_canister_id(id)
    } else {
        result
    };
    if let Some(wasm) = wasm() {
        result.with_wasm(wasm)
    } else {
        result
    }
}
pub fn canister_id() -> Option<Principal> {
    None
}

pub fn wasm() -> Option<Vec<u8>> {
    let mut path = std::path::PathBuf::new();
    path.push("../target/wasm32-wasip1/release/canister_initial_backend_nowasi.wasm");
    let wasm =
        std::fs::read(path.as_path()).unwrap_or_else(|_| panic!("wasm binary not found: {path:?}"));
    Some(wasm)
}
